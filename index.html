<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Data Heist</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        canvas { display: block; }
        
        /* HUD */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        .hud-row {
            display: flex;
            align-items: center;
            gap: 15px;
            text-shadow: 2px 2px 0 #000;
        }
        .label { font-weight: 900; font-size: 24px; min-width: 110px; }
        .value { font-size: 24px; color: #fff; font-weight: bold; }

        /* Focus Bar */
        #focus-bar-bg {
            width: 200px;
            height: 12px;
            background: #222;
            border: 2px solid #555;
        }
        #focus-fill {
            width: 100%;
            height: 100%;
            background: #00ffaa;
            box-shadow: 0 0 10px #00ffaa;
            transition: width 0.1s linear;
        }

        /* Score/Level */
        #top-right-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            pointer-events: none;
        }
        .big-text { font-size: 30px; font-weight: bold; text-shadow: 2px 2px 0 #000; }

        /* Messages */
        #center-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 20;
        }
        #center-msg h1 {
            font-size: 80px;
            margin: 0;
            color: #fff;
            text-shadow: 0 0 20px #0f0;
            text-transform: uppercase;
        }
        
        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        button {
            margin-top: 30px;
            padding: 20px 40px;
            font-size: 28px;
            font-family: inherit;
            background: #00aaff;
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 0 20px #00aaff;
        }
        button:hover { background: #0088cc; }
        .instructions {
            text-align: center;
            color: #ccc;
            font-size: 18px;
            line-height: 1.6;
            max-width: 600px;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-row">
        <div class="label" style="color:#00FFFF">WEAPON:</div>
        <div class="value" id="hud-weapon">DATA-BLADE</div>
    </div>
    <div class="hud-row">
        <div class="label" style="color:#FFFF00">AMMO:</div>
        <div class="value" id="hud-ammo">∞</div>
    </div>
    <div class="hud-row">
        <div class="label" style="color:#00FF00">FOCUS:</div>
        <div id="focus-bar-bg"><div id="focus-fill"></div></div>
    </div>
</div>

<div id="top-right-ui">
    <div class="big-text" id="hud-score">SCORE: 0</div>
    <div class="big-text" id="hud-level" style="color:#aaa; font-size: 20px;">LEVEL 1</div>
</div>

<div id="center-msg">
    <h1 id="msg-text">CLEARED</h1>
</div>

<div id="start-screen">
    <h1 style="color:#00FFFF; font-size:60px; text-shadow:0 0 20px #00FFFF; margin-bottom:10px;">DATA HEIST</h1>
    <div class="instructions">
        WASD to Move | SPACE to Dash (Invincible)<br>
        SHIFT to Slow Time | R-CLICK to Throw Weapon<br>
        Kill all enemies to advance.<br>
        <br>
        <span style="color:#ff5555">WARNING: ENEMIES ARE LETHAL</span>
    </div>
    <button onclick="startGame()">JACK IN</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * AUDIO SYSTEM (Synthesizer)
 */
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol=0.1, slide=0) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide !== 0) {
            osc.frequency.exponentialRampToValueAtTime(freq + slide, this.ctx.currentTime + duration);
        }
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol=0.2) {
        if(!this.ctx) return;
        const bufSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    // Sound Presets
    shoot: function(type) {
        if(type === 'Pistol') this.playTone(600, 'square', 0.1, 0.05, -200);
        else if(type === 'Shotgun') { this.playNoise(0.15, 0.2); this.playTone(150, 'sawtooth', 0.15, 0.1); }
        else if(type === 'SMG') this.playTone(800, 'triangle', 0.05, 0.05, -100);
        else if(type === 'Grenade Launcher') this.playTone(200, 'square', 0.3, 0.1, -100);
        else if(type === 'Data-Blade') this.playNoise(0.1, 0.05);
    },
    enemyShoot: function() { this.playTone(300, 'sawtooth', 0.1, 0.05); },
    dash: function() { this.playNoise(0.2, 0.05); this.playTone(200, 'sine', 0.2, 0.05, 300); },
    explode: function() { this.playNoise(0.4, 0.3); },
    pickup: function() { this.playTone(1000, 'sine', 0.1, 0.05, 500); },
    slowMo: function() { this.playTone(100, 'sine', 0.5, 0.05); }
};

/**
 * ENGINE & STATE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Game State
let gameState = 'menu';
let level = 1;
let score = 0;
let frameCount = 0;
let timeScale = 1.0;
let baseTimeScale = 1.0;
let isLevelLoading = false; // CRITICAL FIX: Level Loop Glitch
let camShake = 0;

// Inputs
const keys = {};
const mouse = { x: 0, y: 0 };
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', e => {
    if(gameState === 'playing' && player && !player.dead) {
        if(e.button === 0) player.trigger = true;
        if(e.button === 2) player.throwWeapon();
    }
});
window.addEventListener('mouseup', e => {
    if(player) player.trigger = false;
});
window.addEventListener('contextmenu', e => e.preventDefault());

// Entities
let player;
let walls = [];
let enemies = [];
let bullets = [];
let particles = [];
let pickups = [];
let ghosts = []; // Dash trails

/**
 * MATH & COLLISION HELPERS
 */
function rand(min, max) { return Math.random() * (max - min) + min; }
function getAngle(x1, y1, x2, y2) { return Math.atan2(y2 - y1, x2 - x1); }
function checkRect(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
            r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

// CRITICAL FIX: Smart Spawning
// Loops until it finds a spot not overlapping any wall
function getSafeSpawnPosition(w, h) {
    let safe = false;
    let x, y;
    let attempts = 0;
    while (!safe && attempts < 200) {
        attempts++;
        x = rand(50, width - 50);
        y = rand(50, height - 50);
        
        // Assume safe, check collision
        safe = true;
        
        // Check walls (add padding)
        let entRect = { x: x - w/2, y: y - h/2, w: w, h: h };
        for (let wall of walls) {
            if (checkRect(entRect, wall)) {
                safe = false;
                break;
            }
        }
        
        // Prevent spawning on player
        if (player) {
            if (Math.hypot(x - player.x, y - player.y) < 300) safe = false;
        }
    }
    // Fallback if map is too crowded (unlikely)
    if (!safe) { x = width/2; y = height/2; } 
    return { x, y };
}

/**
 * CLASSES
 */

class Weapon {
    constructor(type) {
        this.type = type;
        this.timer = 0;
        this.cooldown = 0;
        // Config
        if (type === 'Pistol') { this.color = '#FF0'; this.ammo = 12; this.cooldown = 15; }
        else if (type === 'Shotgun') { this.color = '#0FF'; this.ammo = 6; this.cooldown = 45; }
        else if (type === 'SMG') { this.color = '#A0F'; this.ammo = 32; this.cooldown = 5; }
        else if (type === 'Grenade Launcher') { this.color = '#0F0'; this.ammo = 4; this.cooldown = 60; }
        else { this.type = 'Data-Blade'; this.color = '#FFF'; this.ammo = Infinity; this.cooldown = 20; }
    }
}

class Bullet {
    constructor(x, y, angle, speed, color, owner, type) {
        this.x = x; this.y = y; this.angle = angle;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.color = color;
        this.owner = owner; // 'player' or 'enemy'
        this.type = type; // 'normal', 'melee', 'grenade', 'thrown'
        this.life = (type === 'melee') ? 8 : (type === 'grenade' ? 120 : 150);
        this.radius = (type === 'melee') ? 70 : (type === 'grenade' ? 6 : 3);
        this.dead = false;
    }
    update() {
        // Melee doesn't move, it's an attached arc (visualized statically here)
        if (this.type !== 'melee') {
            this.x += this.vx * timeScale;
            this.y += this.vy * timeScale;
        }
        
        this.life -= 1 * timeScale;
        if (this.life <= 0) {
            this.dead = true;
            if (this.type === 'grenade') explode(this.x, this.y);
        }

        // Wall Collision (CRITICAL: SNIPER NERF - even fast bullets check walls)
        if (this.type !== 'melee') {
            // Simple point check for bullets is usually enough, but for precision:
            for (let w of walls) {
                if (this.x > w.x && this.x < w.x + w.w && 
                    this.y > w.y && this.y < w.y + w.h) {
                    this.dead = true;
                    if (this.type === 'grenade') explode(this.x, this.y);
                    else spawnParticles(this.x, this.y, this.color, 3);
                    return;
                }
            }
        }
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.type === 'melee') {
            ctx.rotate(this.angle);
            ctx.strokeStyle = '#FFF'; ctx.lineWidth = 4; ctx.shadowBlur = 10; ctx.shadowColor = '#FFF';
            ctx.beginPath(); ctx.arc(0, 0, this.radius, -Math.PI/2, Math.PI/2); ctx.stroke();
            ctx.fillStyle = "rgba(255,255,255,0.2)"; ctx.fill();
        } else if (this.type === 'thrown') {
            ctx.rotate(frameCount * 0.5);
            ctx.fillStyle = this.color; ctx.fillRect(-6,-6,12,12);
        } else if (this.type === 'grenade') {
            ctx.fillStyle = '#0F0'; ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
        } else {
            ctx.fillStyle = this.color; ctx.shadowBlur = 5; ctx.shadowColor = this.color;
            ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

class Player {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = 20; this.h = 20;
        this.weapon = new Weapon('Data-Blade');
        this.dead = false;
        this.angle = 0;
        // Abilities
        this.focus = 100; this.maxFocus = 100;
        this.dashTimer = 0; this.dashCooldown = 0;
        this.trigger = false;
    }
    update() {
        this.angle = getAngle(this.x, this.y, mouse.x, mouse.y);

        // FOCUS (Slow Mo)
        if (keys['ShiftLeft'] && this.focus > 0) {
            baseTimeScale = 0.2;
            this.focus -= 0.5;
            if(frameCount % 10 === 0) AudioSys.slowMo();
        } else {
            baseTimeScale = 1.0;
            if (this.focus < this.maxFocus) this.focus += 0.2;
        }

        // DASH
        if (this.dashCooldown > 0) this.dashCooldown -= 1 * timeScale;
        if (this.dashTimer > 0) {
            this.dashTimer -= 1 * timeScale;
            if(frameCount % 3 === 0) ghosts.push({x:this.x, y:this.y, angle:this.angle, life:0.5});
        }
        if (keys['Space'] && this.dashCooldown <= 0) {
            this.dashTimer = 12; // 0.2s approx
            this.dashCooldown = 60;
            AudioSys.dash();
        }

        // MOVE
        let speed = (this.dashTimer > 0) ? 12 : 4;
        let dx = 0, dy = 0;
        if (keys['KeyW']) dy = -1;
        if (keys['KeyS']) dy = 1;
        if (keys['KeyA']) dx = -1;
        if (keys['KeyD']) dx = 1;

        if (dx || dy) {
            let len = Math.hypot(dx, dy);
            dx /= len; dy /= len;
            
            // X Move
            let nextX = this.x + dx * speed * timeScale;
            let hitX = false;
            for(let w of walls) if(checkRect({x:nextX-10, y:this.y-10, w:20, h:20}, w)) hitX = true;
            if(!hitX) this.x = nextX;

            // Y Move
            let nextY = this.y + dy * speed * timeScale;
            let hitY = false;
            for(let w of walls) if(checkRect({x:this.x-10, y:nextY-10, w:20, h:20}, w)) hitY = true;
            if(!hitY) this.y = nextY;
        }

        // SHOOT
        if (this.weapon.timer > 0) this.weapon.timer -= 1 * timeScale;
        if (this.trigger && this.weapon.timer <= 0) {
            if (this.weapon.type === 'Data-Blade' || this.weapon.ammo > 0) {
                this.shoot();
            } else {
                // Click (Empty)
            }
        }
        
        // Pickups
        for(let i=pickups.length-1; i>=0; i--) {
            let p = pickups[i];
            if (Math.hypot(this.x - p.x, this.y - p.y) < 25) {
                AudioSys.pickup();
                if (this.weapon.type === p.type && this.weapon.type !== 'Data-Blade') {
                    this.weapon.ammo += p.ammo; // Stack
                } else {
                    this.weapon = new Weapon(p.type); // Swap
                    this.weapon.ammo = p.ammo;
                }
                pickups.splice(i, 1);
            }
        }
    }
    shoot() {
        this.weapon.timer = this.weapon.cooldown;
        AudioSys.shoot(this.weapon.type);
        camShake = 4;
        
        // Muzzle Flash Effect
        particles.push({x:this.x + Math.cos(this.angle)*20, y:this.y + Math.sin(this.angle)*20, vx:0, vy:0, life:0.1, color:'#FF0', size:10});

        if(this.weapon.type !== 'Data-Blade') this.weapon.ammo--;

        const spawnB = (ang, spd, type='normal') => {
            bullets.push(new Bullet(this.x, this.y, ang, spd, this.weapon.color, 'player', type));
        };

        let t = this.weapon.type;
        if (t === 'Pistol') spawnB(this.angle, 12);
        else if (t === 'Shotgun') {
            spawnB(this.angle, 12);
            spawnB(this.angle + 0.15, 12);
            spawnB(this.angle - 0.15, 12);
            camShake = 8;
        }
        else if (t === 'SMG') spawnB(this.angle + rand(-0.1, 0.1), 14);
        else if (t === 'Grenade Launcher') spawnB(this.angle, 7, 'grenade');
        else if (t === 'Data-Blade') {
            spawnB(this.angle, 0, 'melee');
            camShake = 2;
        }
    }
    throwWeapon() {
        if(this.weapon.type === 'Data-Blade') return;
        bullets.push(new Bullet(this.x, this.y, this.angle, 16, this.weapon.color, 'player', 'thrown'));
        this.weapon = new Weapon('Data-Blade'); // Revert to melee
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        // Body
        ctx.fillStyle = (this.dashTimer > 0) ? '#AFF' : '#FFF';
        ctx.shadowColor = (this.dashTimer > 0) ? '#0FF' : '#FFF';
        ctx.shadowBlur = 10;
        ctx.fillRect(-10, -10, 20, 20);
        // Gun
        ctx.fillStyle = this.weapon.color;
        ctx.fillRect(5, -4, 14, 8);
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.w = 20; this.h = 20;
        this.type = type;
        this.angle = 0;
        this.dead = false;
        // States: 0=Idle/Move, 1=Attack/Windup, 2=Cooldown
        this.state = 0; 
        this.timer = 0; 

        if (type === 'Rusher') { this.color = '#0F0'; this.hp = 1; this.speed = 2.5; } // Green Triangle
        else if (type === 'Shield') { this.color = '#00F'; this.hp = 2; this.speed = 1.0; } // Blue Arc
        else if (type === 'Sniper') { this.color = '#F0F'; this.hp = 1; this.speed = 0.8; } // Purple
        else if (type === 'Shotgunner') { this.color = '#FA0'; this.hp = 1; this.speed = 1.8; } // Orange Square
        else if (type === 'Minigunner') { this.color = '#F00'; this.hp = 3; this.speed = 0.5; } // Red Pentagon
    }

    update() {
        if (player.dead) return;
        let dist = Math.hypot(player.x - this.x, player.y - this.y);
        let angleToPlayer = getAngle(this.x, this.y, player.x, player.y);
        
        // Raycast line of sight
        let hasLOS = true;
        // Simple line check against walls
        let steps = dist / 20;
        for(let i=0; i<steps; i++) {
            let cx = this.x + Math.cos(angleToPlayer) * (i*20);
            let cy = this.y + Math.sin(angleToPlayer) * (i*20);
            for(let w of walls) {
                if(cx > w.x && cx < w.x+w.w && cy > w.y && cy < w.y+w.h) hasLOS = false;
            }
        }

        // --- AI LOGIC ---
        
        if (this.type === 'Rusher') {
            this.angle = angleToPlayer;
            this.tryMove(angleToPlayer, this.speed);
            if (dist < 25) killPlayer();
        } 
        
        else if (this.type === 'Shield') {
            // Slow turn
            let diff = angleToPlayer - this.angle;
            while (diff < -Math.PI) diff += Math.PI*2;
            while (diff > Math.PI) diff -= Math.PI*2;
            this.angle += diff * 0.05 * timeScale;
            
            if (dist > 150) this.tryMove(this.angle, this.speed);
            
            // Fire pistol occasionally
            if (this.timer > 0) this.timer -= 1 * timeScale;
            else if (hasLOS && dist < 300) {
                this.shoot(0, 8);
                this.timer = 120; // 2 sec cooldown
            }
        }
        
        else if (this.type === 'Sniper') {
            if (this.state === 0) { // Moving
                if (hasLOS) { this.state = 1; this.timer = 90; AudioSys.playTone(600, 'sine', 0.1); } // Windup 1.5s
                else this.tryMove(this.angle + rand(-0.5, 0.5), this.speed);
            } else if (this.state === 1) { // Aiming
                this.angle = angleToPlayer;
                this.timer -= 1 * timeScale;
                if (!hasLOS) this.state = 0; 
                if (this.timer <= 0) {
                    this.shoot(0, 25); // Fast bullet
                    this.state = 2; this.timer = 150;
                }
            } else { // Cooldown
                this.timer -= 1 * timeScale;
                if (this.timer <= 0) this.state = 0;
            }
        }
        
        else if (this.type === 'Shotgunner') {
            this.angle = angleToPlayer;
            if (dist > 100) this.tryMove(angleToPlayer, this.speed);
            
            if (this.timer > 0) this.timer -= 1 * timeScale;
            else if (hasLOS && dist < 200) {
                this.shoot(0, 9);
                this.shoot(0.2, 9);
                this.shoot(-0.2, 9);
                this.timer = 100;
            }
        }
        
        else if (this.type === 'Minigunner') {
            if (this.state === 0) { // Idle/Move
                this.angle = angleToPlayer;
                if (dist > 200) this.tryMove(angleToPlayer, this.speed);
                if (hasLOS && dist < 300) { this.state = 1; this.timer = 60; } // Windup
            } else if (this.state === 1) { // Windup
                this.angle = angleToPlayer;
                this.timer -= 1 * timeScale;
                if (this.timer <= 0) { this.state = 2; this.timer = 180; } // Fire for 3s
            } else if (this.state === 2) { // Firing
                this.angle += (angleToPlayer - this.angle) * 0.02; // Slow track
                this.timer -= 1 * timeScale;
                if (frameCount % 5 === 0) this.shoot(rand(-0.2, 0.2), 12); // Stream
                if (this.timer <= 0) { this.state = 3; this.timer = 120; } // Cooldown
            } else { // Cooldown
                this.timer -= 1 * timeScale;
                if (this.timer <= 0) this.state = 0;
            }
        }
    }

    tryMove(angle, spd) {
        let dx = Math.cos(angle) * spd * timeScale;
        let dy = Math.sin(angle) * spd * timeScale;
        
        let nextX = this.x + dx;
        let hitX = false;
        for(let w of walls) if(checkRect({x:nextX-10, y:this.y-10, w:20, h:20}, w)) hitX = true;
        if(!hitX) this.x = nextX;
        
        let nextY = this.y + dy;
        let hitY = false;
        for(let w of walls) if(checkRect({x:this.x-10, y:nextY-10, w:20, h:20}, w)) hitY = true;
        if(!hitY) this.y = nextY;
    }

    shoot(angOffset, spd) {
        AudioSys.enemyShoot();
        bullets.push(new Bullet(this.x, this.y, this.angle + angOffset, spd, this.color, 'enemy', 'normal'));
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color; ctx.shadowBlur = 10;
        
        // Shapes based on type
        ctx.beginPath();
        if (this.type === 'Rusher') { // Triangle
            ctx.moveTo(10, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10);
        } else if (this.type === 'Shield') { // Arc/Circle
            ctx.arc(0,0,10,0,Math.PI*2);
            // Draw Shield
            ctx.strokeStyle = '#0AF'; ctx.lineWidth=3; 
            ctx.beginPath(); ctx.arc(0,0,18,-Math.PI/2, Math.PI/2); ctx.stroke();
        } else if (this.type === 'Sniper') { // Circle with laser
            ctx.arc(0,0,10,0,Math.PI*2);
            if(this.state === 1) { // Laser
                ctx.restore(); ctx.save();
                ctx.strokeStyle = 'rgba(255,0,0,0.5)'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(player.x, player.y); ctx.stroke();
                ctx.restore(); return;
            }
        } else if (this.type === 'Shotgunner') { // Square
            ctx.rect(-10,-10,20,20);
        } else if (this.type === 'Minigunner') { // Pentagon
            for(let i=0; i<5; i++) {
                let a = (i * 2 * Math.PI / 5);
                ctx.lineTo(Math.cos(a)*12, Math.sin(a)*12);
            }
        }
        ctx.fill();
        ctx.restore();
    }
}

/**
 * CORE LOGIC
 */

function spawnParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: rand(-3,3), vy: rand(-3,3),
            life: 1.0, color: color, size: rand(2,5)
        });
    }
}

function explode(x, y) {
    camShake = 15;
    AudioSys.explode();
    // Visual
    particles.push({x:x, y:y, vx:0, vy:0, life:0.5, color:'#FFF', size: 50, alpha:1}); // Flash
    spawnParticles(x, y, '#F50', 20);
    
    // Damage
    for(let i=enemies.length-1; i>=0; i--) {
        let e = enemies[i];
        if (Math.hypot(e.x - x, e.y - y) < 80) killEnemy(i);
    }
    if (Math.hypot(player.x - x, player.y - y) < 60 && player.dashTimer <= 0) {
        player.dead = true;
        AudioSys.explode();
        gameState = 'dead';
        setTimeout(startGame, 2000);
    }
}

function killEnemy(idx) {
    let e = enemies[idx];
    spawnParticles(e.x, e.y, e.color, 8);
    
    // Drop Weapon (30%)
    if (Math.random() < 0.3) {
        let types = ['Pistol', 'Shotgun', 'SMG', 'Grenade Launcher'];
        let t = types[Math.floor(Math.random()*types.length)];
        let w = new Weapon(t);
        pickups.push({x:e.x, y:e.y, type:t, ammo:w.ammo, color:w.color});
    }
    
    score += 100;
    enemies.splice(idx, 1);
}

function killPlayer() {
    if (player.dashTimer > 0) return; // Invincible
    player.dead = true;
    camShake = 20;
    spawnParticles(player.x, player.y, '#FFF', 20);
    AudioSys.explode();
    gameState = 'dead';
    document.getElementById('msg-text').innerText = "WASTED";
    document.getElementById('msg-text').style.color = "#F00";
    document.getElementById('center-msg').style.display = "block";
    setTimeout(startGame, 3000);
}

function generateLevel() {
    walls = [];
    enemies = [];
    pickups = [];
    bullets = [];
    particles = [];
    ghosts = [];
    isLevelLoading = false;
    document.getElementById('center-msg').style.display = 'none';

    // Borders
    walls.push({x:0, y:0, w:width, h:20});
    walls.push({x:0, y:height-20, w:width, h:20});
    walls.push({x:0, y:0, w:20, h:height});
    walls.push({x:width-20, y:0, w:20, h:height});

    // Random Walls
    for(let i=0; i < 10 + level; i++) {
        walls.push({
            x: rand(100, width-200),
            y: rand(100, height-200),
            w: rand(50, 150),
            h: rand(50, 150)
        });
    }

    // Spawn Player
    let pPos = getSafeSpawnPosition(20, 20);
    player = new Player(pPos.x, pPos.y);

    // Spawn Enemies
    let enemyCount = 3 + Math.floor(level * 1.5);
    const types = ['Rusher', 'Shield', 'Sniper', 'Shotgunner', 'Minigunner'];
    
    for(let i=0; i<enemyCount; i++) {
        let pos = getSafeSpawnPosition(20, 20);
        // Progressive difficulty
        let type = types[Math.floor(Math.random() * Math.min(types.length, 1 + level))];
        enemies.push(new Enemy(pos.x, pos.y, type));
    }
    
    // Update UI
    document.getElementById('hud-level').innerText = "LEVEL " + level;
}

function update() {
    timeScale = baseTimeScale;
    
    // Update UI
    document.getElementById('hud-score').innerText = "SCORE: " + score;
    document.getElementById('hud-weapon').innerText = player.weapon.type;
    document.getElementById('hud-ammo').innerText = (player.weapon.ammo === Infinity) ? "∞" : player.weapon.ammo;
    document.getElementById('focus-fill').style.width = player.focus + "%";
    
    // Shake decay
    if(camShake > 0) camShake *= 0.9;
    if(camShake < 0.5) camShake = 0;

    if (!player.dead) player.update();

    // Ghosts
    ghosts.forEach((g, i) => {
        g.life -= 0.05;
        if(g.life<=0) ghosts.splice(i,1);
    });

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.update();
        if (b.dead) { bullets.splice(i, 1); continue; }

        if (b.owner === 'player') {
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                let hit = false;
                
                // Melee Logic
                if (b.type === 'melee') {
                    let dist = Math.hypot(e.x - player.x, e.y - player.y);
                    if (dist < 80) {
                        let ang = getAngle(player.x, player.y, e.x, e.y);
                        let diff = Math.abs(ang - player.angle);
                        while(diff>Math.PI) diff -= Math.PI*2;
                        if(Math.abs(diff) < 1.5) hit = true;
                    }
                } else {
                    if (Math.hypot(b.x - e.x, b.y - e.y) < e.w/2 + b.radius + 5) hit = true;
                }

                if (hit) {
                    // Shield Block
                    if (e.type === 'Shield' && b.type === 'normal') {
                        let ang = getAngle(b.x, b.y, e.x, e.y);
                        let diff = Math.abs(ang - e.angle);
                        while(diff>Math.PI) diff -= Math.PI*2;
                        // Frontal block (approx PI from enemy facing)
                        if (Math.abs(diff) > 2.0) { 
                             b.dead = true; 
                             spawnParticles(b.x, b.y, '#0AF', 3);
                             continue; 
                        }
                    }

                    if(b.type !== 'melee' && b.type !== 'rail') b.dead = true;
                    if(b.type === 'thrown' || b.type === 'grenade') { killEnemy(j); }
                    else {
                        e.hp--;
                        if(e.hp <= 0) killEnemy(j);
                        else {
                            spawnParticles(e.x, e.y, e.color, 3);
                            e.x += Math.cos(b.angle)*5; e.y += Math.sin(b.angle)*5; // Knockback
                        }
                    }
                }
            }
        } else {
            // Enemy Bullet vs Player
            if (!player.dead && Math.hypot(b.x - player.x, b.y - player.y) < 15) {
                killPlayer();
            }
        }
    }

    enemies.forEach(e => e.update());
    
    // Particles
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx * timeScale; p.y += p.vy * timeScale;
        p.life -= 0.05 * timeScale;
        if(p.life <= 0) particles.splice(i, 1);
    }

    // Level End
    if (enemies.length === 0 && !isLevelLoading && !player.dead) {
        isLevelLoading = true;
        document.getElementById('msg-text').innerText = "SECTOR CLEAR";
        document.getElementById('msg-text').style.color = "#0F0";
        document.getElementById('center-msg').style.display = "block";
        setTimeout(() => {
            level++;
            generateLevel();
        }, 2000);
    }
}

function draw() {
    // BG
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    let sx = rand(-camShake, camShake);
    let sy = rand(-camShake, camShake);
    ctx.translate(sx, sy);

    // Walls
    ctx.fillStyle = '#111';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    for(let w of walls) {
        ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.strokeRect(w.x, w.y, w.w, w.h);
    }

    // Pickups
    pickups.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color; ctx.shadowBlur=10;
        ctx.fillRect(p.x-5, p.y-5, 10, 10);
    });

    // Ghosts
    ghosts.forEach(g => {
        ctx.save(); ctx.translate(g.x, g.y); ctx.rotate(g.angle);
        ctx.globalAlpha = g.life;
        ctx.fillStyle = '#0FF'; ctx.fillRect(-10,-10,20,20);
        ctx.restore();
    });

    if(!player.dead) player.draw();
    enemies.forEach(e => e.draw());
    bullets.forEach(b => b.draw());
    
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        let s = p.size;
        if(p.alpha) s = p.size * p.life;
        ctx.fillRect(p.x, p.y, s, s);
    });

    ctx.restore();
    frameCount++;
}

function loop() {
    if (gameState === 'playing') update();
    draw();
    requestAnimationFrame(loop);
}

function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    AudioSys.init();
    gameState = 'playing';
    level = 1;
    score = 0;
    generateLevel();
    loop();
}
</script>
</body>
</html>
