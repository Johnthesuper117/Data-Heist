<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EXECUTIONER.EXE: REWIRED</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas { 
            display: block; 
            transition: filter 0.1s;
        }
        
        /* SLOW MO EFFECT */
        .slow-mo {
            filter: invert(1) hue-rotate(180deg) contrast(1.2);
        }

        /* HUD LAYOUT */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }

        /* STYLE METER (Right Side) */
        #style-container {
            position: absolute;
            right: 40px;
            top: 40%;
            transform: translateY(-50%);
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        #style-grade {
            font-size: 140px;
            font-weight: 900;
            font-style: italic;
            line-height: 0.9;
            text-shadow: 5px 5px 0px #000, 0 0 30px currentColor;
            transition: transform 0.1s;
        }
        #style-bar-bg {
            width: 350px;
            height: 20px;
            background: #111;
            border: 3px solid #444;
            margin-top: 10px;
            transform: skewX(-20deg);
        }
        #style-bar-fill {
            width: 0%;
            height: 100%;
            background: #fff;
            transition: width 0.1s linear;
        }
        #style-words {
            font-size: 32px;
            color: #ccc;
            margin-top: 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 2px 2px 0 #000;
        }

        /* TOP LEFT HUD */
        .hud-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        .label { font-weight: 900; font-size: 24px; color: #00ffff; text-shadow: 0 0 10px #00ffff; }
        .value { font-size: 24px; font-weight: bold; font-family: monospace; }
        
        #focus-bar-bg { width: 250px; height: 12px; background: #222; border: 2px solid #555; transform: skewX(-20deg); }
        #focus-fill { width: 100%; height: 100%; background: #ff00ff; box-shadow: 0 0 10px #ff00ff; }

        /* CENTER MESSAGES */
        #center-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 20;
        }
        #center-msg h1 {
            font-size: 100px; margin: 0;
            text-transform: uppercase;
            font-style: italic;
            font-weight: 900;
            text-shadow: 0 0 30px currentColor;
            letter-spacing: 5px;
        }

        /* START SCREEN */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5,5,5,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        button {
            margin-top: 40px;
            padding: 25px 60px;
            font-size: 30px;
            font-family: inherit;
            background: #00ffff;
            color: #000;
            border: none;
            cursor: pointer;
            font-weight: 900;
            transform: skewX(-10deg);
            box-shadow: 8px 8px 0 #ff00ff;
            transition: transform 0.1s;
        }
        button:hover { transform: skewX(-10deg) scale(1.05); background: #fff; }
        .inst-box {
            background: #111;
            padding: 30px;
            border: 2px solid #333;
            text-align: center;
            max-width: 700px;
            box-shadow: 0 0 20px rgba(0,255,255,0.1);
        }
        .key { color: #ff00ff; font-weight: bold; }
        .mech { color: #00ffff; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="top-left">
        <div class="hud-row">
            <div class="label">WEAPON</div>
            <div class="value" id="hud-weapon" style="color:#FFF">DATA-BLADE</div>
        </div>
        <div class="hud-row">
            <div class="label">AMMO</div>
            <div class="value" id="hud-ammo" style="color:#FF0">âˆž</div>
        </div>
        <div class="hud-row">
            <div class="label">FOCUS</div>
            <div id="focus-bar-bg"><div id="focus-fill"></div></div>
        </div>
        <div class="hud-row">
            <div class="label" style="color:#888; font-size:18px;">SECTOR</div>
            <div class="value" id="hud-level" style="font-size:18px;">1</div>
        </div>
    </div>

    <div id="style-container">
        <div id="style-grade">D</div>
        <div id="style-bar-bg"><div id="style-bar-fill"></div></div>
        <div id="style-words">DULL</div>
    </div>
</div>

<div id="center-msg"><h1 id="msg-text">EXECUTED</h1></div>

<div id="start-screen">
    <h1 style="color:#00ffff; font-size:80px; margin:0 0 20px 0; text-shadow:4px 4px 0 #ff00ff; font-style:italic;">EXECUTIONER.EXE</h1>
    <div class="inst-box">
        <div style="font-size: 20px; line-height: 1.8; color: #ddd;">
            <span class="key">WASD</span> Move (Fast) | <span class="key">SPACE</span> Dash (Dodge) | <span class="key">SHIFT</span> Focus (Slow-Mo)<br>
            <span class="key">L-CLICK</span> Attack | <span class="key">R-CLICK</span> Throw Gun<br>
            <br>
            <span class="mech">PARRY</span>: Slash enemy bullets.<br>
            <span class="mech">FLEX</span>: Slash THROWN GUNS for massive style.<br>
            <span class="mech">SHIELD</span>: Frontal immunity. Use MELEE to bypass.<br>
        </div>
    </div>
    <button onclick="startGame()">INITIATE SEQUENCE</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * AUDIO SYSTEM (Synth)
 */
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol=0.1, slide=0) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide !== 0) osc.frequency.exponentialRampToValueAtTime(freq + slide, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol=0.2) {
        if(!this.ctx) return;
        const bufSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain).connect(this.ctx.destination);
        noise.start();
    },
    shoot: function(type) {
        if(type === 'Pistol') this.playTone(600, 'square', 0.1, 0.1, -300);
        else if(type === 'Shotgun') { this.playNoise(0.2, 0.2); this.playTone(100, 'sawtooth', 0.2, 0.15); }
        else if(type === 'SMG') this.playTone(800, 'triangle', 0.05, 0.05, -200);
        else if(type === 'Grenade Launcher') this.playTone(200, 'square', 0.3, 0.2, -150);
        else if(type === 'Data-Blade') this.playNoise(0.05, 0.1);
    },
    parry: function() { this.playTone(1500, 'sine', 0.3, 0.2, 500); this.playTone(1000, 'square', 0.1, 0.1); },
    flex: function() { this.playTone(400, 'sawtooth', 0.4, 0.2, 800); this.playNoise(0.2, 0.3); },
    dodge: function() { this.playTone(600, 'sine', 0.3, 0.2, 600); },
    kill: function() { this.playNoise(0.1, 0.1); this.playTone(100, 'sawtooth', 0.2, 0.2, -50); },
    explode: function() { this.playNoise(0.6, 0.4); }
};

/**
 * STYLE SYSTEM
 */
const Style = {
    points: 0, meter: 0, maxMeter: 100, decayTimer: 0, gradeIndex: 0,
    grades: ['D', 'C', 'B', 'A', 'S', 'SS', 'SSS'],
    gradeColors: ['#666', '#FFF', '#0FF', '#0F0', '#FF0', '#FA0', '#F0F'],
    words: ['DULL', 'COOL', 'BRAVE', 'ATOMIC', 'SADISTIC', 'SSADISTIC', 'SSSMOKIN!'],
    texts: [],

    update: function(dt) {
        this.decayTimer += dt;
        // Decay logic
        if(this.decayTimer > 3.0 && this.meter > 0) {
            this.meter -= 40 * dt;
            if(this.meter < 0) {
                this.meter = 100;
                if(this.gradeIndex > 0) this.gradeIndex--;
                else this.meter = 0;
            }
        }
        
        // Grade Up Logic
        if(this.meter >= this.maxMeter) {
            if(this.gradeIndex < this.grades.length - 1) {
                this.gradeIndex++;
                this.meter = 15;
                AudioSys.playTone(400 + (this.gradeIndex*100), 'triangle', 0.5, 0.2);
            } else {
                this.meter = this.maxMeter;
            }
        }

        // DOM Update
        const g = document.getElementById('style-grade');
        g.innerText = this.grades[this.gradeIndex];
        g.style.color = this.gradeColors[this.gradeIndex];
        document.getElementById('style-bar-fill').style.width = (this.meter / this.maxMeter * 100) + '%';
        document.getElementById('style-bar-fill').style.backgroundColor = this.gradeColors[this.gradeIndex];
        document.getElementById('style-words').innerText = this.words[this.gradeIndex];

        // Floating Texts
        for(let i=this.texts.length-1; i>=0; i--) {
            let t = this.texts[i];
            t.y -= 50 * dt; // Float up
            t.life -= dt;
            if(t.life <= 0) this.texts.splice(i, 1);
        }
    },

    add: function(amount, label, x, y) {
        this.decayTimer = 0;
        this.points += amount;
        this.meter += amount;
        if(label) {
            this.texts.push({
                x: x + (Math.random()*20-10), y: y - 30, 
                text: label, color: this.gradeColors[Math.min(this.gradeIndex+1, 6)],
                life: 1.2, size: 24 + (amount/3)
            });
        }
    },

    getBuffs: function() {
        let m = 1.0 + (this.gradeIndex * 0.15);
        return { speed: m, cooldown: 1/m, slowMo: m };
    }
};

/**
 * ENGINE SETUP
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Constants
const CELL_SIZE = 80; // Large grid for spacious map

// State
let gameState = 'menu';
let level = 1;
let lastTime = 0;
let timeScale = 1.0;
let baseTimeScale = 1.0;
let isLevelLoading = false;
let camShake = 0;

// Entities
let player;
let walls = [];
let enemies = [];
let bullets = [];
let particles = [];
let pickups = [];

// Input
const keys = {};
const mouse = { x: 0, y: 0 };
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', e => {
    if(gameState === 'playing' && player && !player.dead) {
        if(e.button === 0) player.trigger = true;
        if(e.button === 2) player.throwWeapon();
    }
});
window.addEventListener('mouseup', e => { if(player) player.trigger = false; });
window.addEventListener('contextmenu', e => e.preventDefault());

/**
 * PHYSICS & MATH
 */
function checkRect(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
            r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

function resolveMove(entity, dx, dy) {
    // X Axis
    entity.x += dx;
    let hitX = false;
    let bounds = {x: entity.x - entity.w/2, y: entity.y - entity.h/2, w: entity.w, h: entity.h};
    for(let w of walls) {
        if(checkRect(bounds, w)) {
            hitX = true;
            if(dx > 0) entity.x = w.x - entity.w/2 - 0.1;
            else if(dx < 0) entity.x = w.x + w.w + entity.w/2 + 0.1;
            break;
        }
    }
    
    // Y Axis
    entity.y += dy;
    bounds.x = entity.x - entity.w/2; bounds.y = entity.y - entity.h/2; // Update bounds with new X
    for(let w of walls) {
        if(checkRect(bounds, w)) {
            if(dy > 0) entity.y = w.y - entity.h/2 - 0.1;
            else if(dy < 0) entity.y = w.y + w.h + entity.h/2 + 0.1;
            break;
        }
    }
}

function checkLOS(x1, y1, x2, y2) {
    let dist = Math.hypot(x2-x1, y2-y1);
    let steps = dist / CELL_SIZE;
    let angle = Math.atan2(y2-y1, x2-x1);
    for(let i=1; i<steps; i++) {
        let tx = x1 + Math.cos(angle)*(i*CELL_SIZE);
        let ty = y1 + Math.sin(angle)*(i*CELL_SIZE);
        for(let w of walls) {
            if (tx > w.x && tx < w.x+w.w && ty > w.y && ty < w.y+w.h) return false;
        }
    }
    return true;
}

function getSafeSpawn() {
    let attempts = 0;
    while(attempts < 1000) {
        let x = Math.random() * (width - 120) + 60;
        let y = Math.random() * (height - 120) + 60;
        let safe = true;
        for(let w of walls) {
            if(checkRect({x:x-20, y:y-20, w:40, h:40}, w)) safe = false;
        }
        if(safe && player) {
            if(Math.hypot(x-player.x, y-player.y) < 400) safe = false;
        }
        if(safe) return {x, y};
        attempts++;
    }
    return {x: width/2, y: height/2};
}

/**
 * CLASSES
 */
class Weapon {
    constructor(type) {
        this.type = type;
        this.timer = 0;
        // Faster cooldowns for snappier combat
        if (type === 'Pistol') { this.color = '#FF0'; this.ammo = 12; this.cooldown = 0.2; }
        else if (type === 'Shotgun') { this.color = '#0FF'; this.ammo = 6; this.cooldown = 0.8; }
        else if (type === 'SMG') { this.color = '#A0F'; this.ammo = 32; this.cooldown = 0.08; }
        else if (type === 'Grenade Launcher') { this.color = '#0F0'; this.ammo = 4; this.cooldown = 1.0; }
        else { this.type = 'Data-Blade'; this.color = '#FFF'; this.ammo = Infinity; this.cooldown = 0.3; }
    }
}

class Bullet {
    constructor(x, y, angle, speed, color, owner, type) {
        this.x = x; this.y = y; this.angle = angle;
        // Increased base projectile speeds
        let buff = (owner === 'player' && type !== 'melee') ? Style.getBuffs().speed : 1.0;
        this.vx = Math.cos(angle) * speed * buff;
        this.vy = Math.sin(angle) * speed * buff;
        this.color = color;
        this.owner = owner;
        this.type = type; 
        this.life = type === 'melee' ? 0.1 : 3.0;
        this.radius = type === 'melee' ? 100 : (type==='grenade'?8:(type==='thrown'?12:4));
        this.dead = false;
        this.spin = 0;
    }
    update(dt) {
        if (this.type === 'thrown') this.spin += 15 * dt;
        
        if (this.type !== 'melee') {
            this.x += this.vx * dt * timeScale;
            this.y += this.vy * dt * timeScale;
        }
        
        this.life -= dt * timeScale;
        if (this.life <= 0) {
            this.dead = true;
            if (this.type === 'grenade') explode(this.x, this.y, this.owner);
        }

        if (this.type !== 'melee' && this.type !== 'rail') {
            for (let w of walls) {
                if (this.x > w.x && this.x < w.x + w.w && this.y > w.y && this.y < w.y + w.h) {
                    this.dead = true;
                    if (this.type === 'grenade') explode(this.x, this.y, this.owner);
                    else spawnParticles(this.x, this.y, this.color, 3);
                    return;
                }
            }
        }
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.type === 'melee') {
            ctx.rotate(this.angle);
            ctx.fillStyle = "rgba(0, 255, 255, 0.2)";
            ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0, 0, this.radius, -Math.PI/3, Math.PI/3); ctx.fill();
            ctx.strokeStyle = "#0FF"; ctx.lineWidth = 3; ctx.stroke();
        } else if (this.type === 'thrown') {
            ctx.rotate(this.spin);
            ctx.fillStyle = this.color; ctx.fillRect(-12, -5, 24, 10);
        } else if (this.type === 'grenade') {
            ctx.fillStyle = '#0F0'; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
        } else {
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 5; ctx.shadowColor = this.color;
            ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

class Player {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = 24; this.h = 24;
        this.weapon = new Weapon('Data-Blade');
        this.dead = false;
        this.angle = 0;
        this.focus = 100; this.maxFocus = 100;
        this.dashTimer = 0; this.dashCooldown = 0;
        this.trigger = false;
    }
    update(dt) {
        // Look at mouse
        this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        let buffs = Style.getBuffs();

        // Focus / Slow Mo
        if (keys['ShiftLeft'] && this.focus > 0) {
            baseTimeScale = 0.2;
            canvas.classList.add('slow-mo');
            this.focus -= 30 * dt * (1/buffs.slowMo); 
        } else {
            baseTimeScale = 1.0;
            canvas.classList.remove('slow-mo');
            if (this.focus < this.maxFocus) this.focus += 15 * dt;
        }

        // Dash
        if (this.dashCooldown > 0) this.dashCooldown -= dt * timeScale;
        if (this.dashTimer > 0) this.dashTimer -= dt * timeScale;

        if (keys['Space'] && this.dashCooldown <= 0) {
            this.dashTimer = 0.25; 
            this.dashCooldown = 1.0 * buffs.cooldown;
            AudioSys.dodge();
            spawnParticles(this.x, this.y, '#0FF', 8);
        }

        // Movement (Snappy 300 base speed + 20% = 360)
        let moveSpeed = (this.dashTimer > 0) ? 900 : 360; 
        let dx = 0, dy = 0;
        if (keys['KeyW']) dy = -1;
        if (keys['KeyS']) dy = 1;
        if (keys['KeyA']) dx = -1;
        if (keys['KeyD']) dx = 1;

        if (dx || dy) {
            let len = Math.hypot(dx, dy);
            dx /= len; dy /= len;
            // Apply Move with Slide Logic
            resolveMove(this, dx * moveSpeed * dt * timeScale, dy * moveSpeed * dt * timeScale);
        }

        // Weapon Timer
        if (this.weapon.timer > 0) this.weapon.timer -= dt * timeScale;
        
        // Shoot
        if (this.trigger && this.weapon.timer <= 0) {
            if (this.weapon.type === 'Data-Blade' || this.weapon.ammo > 0) this.shoot();
        }

        // Pickups
        for(let i=pickups.length-1; i>=0; i--) {
            let p = pickups[i];
            if (Math.hypot(this.x - p.x, this.y - p.y) < 30) {
                AudioSys.playTone(800, 'sine', 0.1);
                if (this.weapon.type === p.type && this.weapon.type !== 'Data-Blade') {
                    this.weapon.ammo += p.ammo; 
                } else {
                    this.weapon = new Weapon(p.type); 
                    this.weapon.ammo = p.ammo;
                }
                pickups.splice(i, 1);
            }
        }
    }
    shoot() {
        this.weapon.timer = this.weapon.cooldown;
        AudioSys.shoot(this.weapon.type);
        camShake = 5;
        if(this.weapon.type !== 'Data-Blade') this.weapon.ammo--;

        const spawnB = (ang, spd, type='normal') => {
            bullets.push(new Bullet(this.x, this.y, ang, spd, this.weapon.color, 'player', type));
        };

        let t = this.weapon.type;
        if (t === 'Pistol') spawnB(this.angle, 800);
        else if (t === 'Shotgun') {
            spawnB(this.angle, 800); spawnB(this.angle+0.15, 800); spawnB(this.angle-0.15, 800);
        }
        else if (t === 'SMG') spawnB(this.angle + (Math.random()*0.2-0.1), 900);
        else if (t === 'Grenade Launcher') spawnB(this.angle, 500, 'grenade');
        else if (t === 'Data-Blade') {
            spawnB(this.angle, 0, 'melee');
            checkMeleeHit(this.x, this.y, this.angle);
        }
    }
    throwWeapon() {
        if(this.weapon.type === 'Data-Blade') return;
        bullets.push(new Bullet(this.x, this.y, this.angle, 700, this.weapon.color, 'player', 'thrown'));
        this.weapon = new Weapon('Data-Blade'); 
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = (this.dashTimer > 0) ? '#0FF' : '#FFF';
        ctx.shadowColor = (this.dashTimer > 0) ? '#0FF' : '#FFF';
        ctx.shadowBlur = 15;
        ctx.fillRect(-12, -12, 24, 24);
        ctx.fillStyle = this.weapon.color;
        ctx.fillRect(8, -4, 16, 8);
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.w = 24; this.h = 24;
        this.type = type;
        this.hp = 1;
        this.state = 0; this.timer = 0; 
        
        // Boosted Enemy Speeds
        if (type === 'Rusher') { this.color = '#0F0'; this.speed = 220; }
        else if (type === 'Shield') { this.color = '#00F'; this.hp = 3; this.speed = 100; }
        else if (type === 'Sniper') { this.color = '#A0F'; this.speed = 80; }
        else if (type === 'Shotgunner') { this.color = '#FA0'; this.hp = 2; this.speed = 160; }
        else if (type === 'Minigunner') { this.color = '#F00'; this.hp = 4; this.speed = 60; }
    }

    update(dt) {
        if (player.dead) return;
        let dist = Math.hypot(player.x - this.x, player.y - this.y);
        let angToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
        let hasLOS = checkLOS(this.x, this.y, player.x, player.y);

        // AI Logic
        if (this.type === 'Rusher') {
            this.angle = angToPlayer;
            // Wall Sliding happens inside resolveMove implicitly
            resolveMove(this, Math.cos(angToPlayer)*this.speed*dt*timeScale, Math.sin(angToPlayer)*this.speed*dt*timeScale);
        } 
        else if (this.type === 'Shield') {
            // Turn slowly
            let diff = angToPlayer - this.angle;
            while(diff < -Math.PI) diff+=Math.PI*2; while(diff>Math.PI) diff-=Math.PI*2;
            this.angle += diff * 5 * dt * timeScale;
            
            if (dist > 150) resolveMove(this, Math.cos(this.angle)*this.speed*dt*timeScale, Math.sin(this.angle)*this.speed*dt*timeScale);
            
            this.timer -= dt * timeScale;
            if (this.timer <= 0 && hasLOS && dist < 400) {
                this.shoot(0, 400); this.timer = 2.0;
            }
        }
        else if (this.type === 'Sniper') {
            if(this.state === 0) { // Move
                if(hasLOS) { this.state = 1; this.timer = 1.5; }
                else {
                    // Try to move towards player even if no LOS (corner navigation)
                    resolveMove(this, Math.cos(angToPlayer)*this.speed*dt*timeScale, Math.sin(angToPlayer)*this.speed*dt*timeScale);
                }
            } else if(this.state === 1) { // Aim
                this.angle = angToPlayer;
                this.timer -= dt * timeScale;
                if(this.timer <= 0) { this.shoot(0, 1500); this.state=2; this.timer=2.5; }
            } else { // Cooldown
                this.timer -= dt * timeScale;
                if(this.timer <= 0) this.state = 0;
            }
        }
        else if (this.type === 'Shotgunner') {
            this.angle = angToPlayer;
            if(dist > 150) resolveMove(this, Math.cos(angToPlayer)*this.speed*dt*timeScale, Math.sin(angToPlayer)*this.speed*dt*timeScale);
            this.timer -= dt * timeScale;
            if(this.timer <= 0 && hasLOS && dist < 300) {
                this.shoot(0, 500); this.shoot(0.2, 500); this.shoot(-0.2, 500);
                this.timer = 1.8;
            }
        }
        else if (this.type === 'Minigunner') {
            if(this.state === 0) {
                this.angle = angToPlayer;
                if(dist > 250) resolveMove(this, Math.cos(angToPlayer)*this.speed*dt*timeScale, Math.sin(angToPlayer)*this.speed*dt*timeScale);
                if(hasLOS && dist < 400) { this.state = 1; this.timer = 0.8; }
            } else if(this.state === 1) { // Windup
                this.angle = angToPlayer;
                this.timer -= dt * timeScale;
                if(this.timer <= 0) { this.state=2; this.timer=3.0; }
            } else if(this.state === 2) { // Fire
                 // Slow turn while firing
                let diff = angToPlayer - this.angle;
                while(diff < -Math.PI) diff+=Math.PI*2; while(diff>Math.PI) diff-=Math.PI*2;
                this.angle += diff * 2 * dt * timeScale;

                this.timer -= dt * timeScale;
                if(Math.random() < 0.2) this.shoot((Math.random()-0.5)*0.2, 600);
                if(this.timer <= 0) { this.state=3; this.timer=2.0; }
            } else { // Cooldown
                this.timer -= dt * timeScale;
                if(this.timer <= 0) this.state = 0;
            }
        }
    }
    shoot(offset, speed) {
        bullets.push(new Bullet(this.x, this.y, this.angle + offset, speed, this.color, 'enemy', 'normal'));
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        if (this.type === 'Sniper') {
            ctx.strokeStyle = '#FFF'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.stroke();
            if(this.state === 1) {
                ctx.restore(); ctx.save();
                ctx.strokeStyle = `rgba(255,0,255,${Math.random()})`; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(player.x, player.y); ctx.stroke();
                ctx.restore(); return;
            }
        }

        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color; ctx.shadowBlur = 10;
        ctx.beginPath();
        if (this.type === 'Rusher') { ctx.moveTo(12, 0); ctx.lineTo(-12, 12); ctx.lineTo(-12, -12); }
        else if (this.type === 'Shield') { 
            ctx.arc(0,0,12,0,Math.PI*2);
            ctx.strokeStyle = '#0AF'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(0,0,22,-Math.PI/2, Math.PI/2); ctx.stroke();
        } 
        else if (this.type === 'Sniper') ctx.arc(0,0,12,0,Math.PI*2);
        else if (this.type === 'Shotgunner') ctx.rect(-12,-12,24,24);
        else if (this.type === 'Minigunner') {
            for(let i=0; i<5; i++) {
                let a = (i * 2 * Math.PI / 5); ctx.lineTo(Math.cos(a)*14, Math.sin(a)*14);
            }
        }
        ctx.fill();
        ctx.restore();
    }
}

/**
 * GAME MECHANICS
 */
function checkMeleeHit(px, py, angle) {
    let hitSomething = false;

    // 1. Check Bullets (Parry & FLEX)
    for(let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        let dist = Math.hypot(b.x - px, b.y - py);
        
        if(dist < 100 && !b.dead) { // Melee Range
            let angToB = Math.atan2(b.y - py, b.x - px);
            let diff = Math.abs(angToB - angle);
            while(diff > Math.PI) diff -= Math.PI*2;
            
            if(Math.abs(diff) < Math.PI/3) { // 120 degree cone
                
                // NEW: FLEX MECHANIC (Hit Thrown Gun)
                if(b.type === 'thrown') {
                    b.dead = true;
                    Style.add(200, 'FLEXING', b.x, b.y); // Huge Points
                    spawnParticles(b.x, b.y, '#FF0', 15);
                    explode(b.x, b.y, 'player'); // Trigger explosion
                    AudioSys.flex();
                    hitSomething = true;
                }
                // PARRY MECHANIC (Hit Enemy Bullet)
                else if(b.owner === 'enemy') {
                    b.dead = true;
                    Style.add(20, 'PARRY', b.x, b.y);
                    spawnParticles(b.x, b.y, '#FFF', 5);
                    AudioSys.parry();
                    hitSomething = true;
                }
            }
        }
    }

    // 2. Check Enemies (Damage)
    // Note: This logic is now handled in the BULLET UPDATE for the melee projectile, 
    // but we add special effects here if needed.
}

function explode(x, y, owner) {
    camShake = 15;
    AudioSys.explode();
    let r = 100 * (owner === 'player' ? Style.getBuffs().speed : 1.0);
    particles.push({x:x, y:y, vx:0, vy:0, life:0.4, color:'#FFF', size: r, alpha:1});
    spawnParticles(x, y, '#F50', 25);
    
    // Damage Enemies
    let kills = 0;
    for(let i=enemies.length-1; i>=0; i--) {
        let e = enemies[i];
        if(Math.hypot(e.x - x, e.y - y) < r + e.w) {
            killEnemy(i, 'BOOM');
            kills++;
        }
    }
    if(kills > 1) Style.add(kills * 50, 'MULTI-KILL!', x, y);

    // Damage Player
    if(Math.hypot(player.x - x, player.y - y) < r && player.dashTimer <= 0) {
        killPlayer();
    }
}

function killEnemy(idx, txt='KILL') {
    let e = enemies[idx];
    spawnParticles(e.x, e.y, e.color, 12);
    if(Math.random() < 0.3) {
        let types = ['Pistol', 'Shotgun', 'SMG', 'Grenade Launcher'];
        let t = types[Math.floor(Math.random()*types.length)];
        let w = new Weapon(t);
        pickups.push({x:e.x, y:e.y, type:t, ammo:w.ammo, color:w.color});
    }
    Style.add(50, txt, e.x, e.y);
    AudioSys.kill();
    enemies.splice(idx, 1);
}

function killPlayer() {
    player.dead = true;
    gameState = 'dead';
    AudioSys.explode();
    document.getElementById('msg-text').innerText = "TERMINATED";
    document.getElementById('msg-text').style.color = "#F00";
    document.getElementById('center-msg').style.display = "block";
    setTimeout(startGame, 2500);
}

function spawnParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        let ang = Math.random() * Math.PI * 2;
        let spd = Math.random() * 200;
        particles.push({
            x: x, y: y,
            vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd,
            life: Math.random() * 0.5 + 0.2, color: color, size: Math.random()*5+2
        });
    }
}

/**
 * MAP GEN (SPACIOUS)
 */
function generateLevel() {
    walls = []; enemies = []; pickups = []; bullets = []; particles = [];
    isLevelLoading = false;
    document.getElementById('center-msg').style.display = 'none';

    // 1. Grid Setup
    let gw = Math.floor(width/CELL_SIZE);
    let gh = Math.floor(height/CELL_SIZE);
    let grid = [];
    for(let y=0; y<gh; y++) {
        let row = [];
        for(let x=0; x<gw; x++) row.push(1); // 1 = Wall
        grid.push(row);
    }

    // 2. Random Walker for Spacious Rooms
    let cx = Math.floor(gw/2), cy = Math.floor(gh/2);
    let walkers = [{x:cx, y:cy}];
    let floorCount = 0;
    let targetFloors = (gw * gh) * 0.5; // 50% open space

    while(floorCount < targetFloors) {
        let wIdx = Math.floor(Math.random() * walkers.length);
        let w = walkers[wIdx];
        
        // Carve 3x3 area for width
        for(let dy=-1; dy<=1; dy++) {
            for(let dx=-1; dx<=1; dx++) {
                if(w.y+dy > 1 && w.y+dy < gh-2 && w.x+dx > 1 && w.x+dx < gw-2) {
                    if(grid[w.y+dy][w.x+dx] === 1) {
                        grid[w.y+dy][w.x+dx] = 0;
                        floorCount++;
                    }
                }
            }
        }

        // Move Walker
        let dir = Math.floor(Math.random()*4);
        if(dir===0) w.y -= 2;
        else if(dir===1) w.y += 2;
        else if(dir===2) w.x -= 2;
        else if(dir===3) w.x += 2;

        // Keep bounds
        w.x = Math.max(2, Math.min(gw-3, w.x));
        w.y = Math.max(2, Math.min(gh-3, w.y));

        // Add new walker rarely
        if(Math.random() < 0.05) walkers.push({x:w.x, y:w.y});
    }

    // 3. Build Walls from Grid
    for(let y=0; y<gh; y++) {
        for(let x=0; x<gw; x++) {
            if(grid[y][x] === 1) {
                walls.push({x:x*CELL_SIZE, y:y*CELL_SIZE, w:CELL_SIZE, h:CELL_SIZE});
            }
        }
    }

    // 4. Spawn Entities
    let pPos = getSafeSpawn();
    player = new Player(pPos.x, pPos.y);

    let enemyCount = 5 + level * 2;
    const types = ['Rusher', 'Shield', 'Sniper', 'Shotgunner', 'Minigunner'];
    for(let i=0; i<enemyCount; i++) {
        let pos = getSafeSpawn();
        let t = types[Math.floor(Math.random() * Math.min(types.length, 1 + Math.floor(level/2)))];
        enemies.push(new Enemy(pos.x, pos.y, t));
    }
    document.getElementById('hud-level').innerText = level;
}

/**
 * MAIN LOOP
 */
function update(dt) {
    Style.update(dt);
    if(camShake > 0) camShake *= 0.9;
    
    if (!player.dead) player.update(dt);

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.update(dt);
        if (b.dead) { bullets.splice(i, 1); continue; }

        if (b.owner === 'player') {
            for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                let hit = false;
                
                // Hit Logic
                if (b.type === 'melee') {
                    // Melee hits are checked via cone distance
                    if(Math.hypot(e.x - b.x, e.y - b.y) < b.radius) {
                        let ang = Math.atan2(e.y-b.y, e.x-b.x);
                        let diff = Math.abs(ang - b.angle);
                        while(diff > Math.PI) diff -= Math.PI*2;
                        if(Math.abs(diff) < Math.PI/3) hit = true;
                    }
                } else {
                    if (Math.hypot(b.x - e.x, b.y - e.y) < e.w/2 + b.radius) hit = true;
                }

                if (hit) {
                    // Shield: Only blocks NORMAL bullets from front. MELEE kills instantly.
                    if (e.type === 'Shield' && b.type === 'normal') {
                        let ang = Math.atan2(b.y - e.y, b.x - e.x);
                        let diff = Math.abs(ang - e.angle);
                        while(diff>Math.PI) diff -= Math.PI*2;
                        if (Math.abs(diff) < 1.5) { // Blocked
                            b.dead = true; spawnParticles(b.x, b.y, '#0AF', 5); continue;
                        }
                    }

                    if(b.type !== 'melee') b.dead = true;
                    if(b.type === 'thrown' || b.type === 'grenade') killEnemy(j, 'CRUSHED');
                    else {
                        e.hp--;
                        spawnParticles(e.x, e.y, e.color, 5);
                        // Melee kills shield instantly
                        if(b.type === 'melee' && e.type === 'Shield') e.hp = 0;
                        
                        if(e.hp <= 0) killEnemy(j, b.type==='melee'?'SLICED':'KILL');
                    }
                }
            }
        } else {
            // Enemy Bullet vs Player
            if (!player.dead && Math.hypot(b.x - player.x, b.y - player.y) < 15) {
                if (player.dashTimer > 0) {
                    b.dead = true;
                    Style.add(50, 'DODGE', player.x, player.y);
                    AudioSys.dodge();
                } else {
                    killPlayer();
                }
            }
        }
    }

    enemies.forEach(e => e.update(dt));
    
    // Particles
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx * dt * timeScale; p.y += p.vy * dt * timeScale;
        p.life -= dt * timeScale;
        if(p.life <= 0) particles.splice(i, 1);
    }

    // Win
    if (enemies.length === 0 && !isLevelLoading && !player.dead) {
        isLevelLoading = true;
        document.getElementById('msg-text').innerText = "SECTOR CLEAR";
        document.getElementById('msg-text').style.color = "#0F0";
        document.getElementById('center-msg').style.display = "block";
        setTimeout(() => { level++; generateLevel(); }, 2000);
    }
}

function draw() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);
    ctx.save();
    let sx = (Math.random()-0.5)*camShake;
    let sy = (Math.random()-0.5)*camShake;
    ctx.translate(sx, sy);

    // Floor Grid
    ctx.strokeStyle = '#111'; ctx.lineWidth = 2; ctx.beginPath();
    for(let x=0; x<width; x+=CELL_SIZE) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
    for(let y=0; y<height; y+=CELL_SIZE) { ctx.moveTo(0,y); ctx.lineTo(width,y); }
    ctx.stroke();

    // Walls
    ctx.shadowBlur = 15;
    for(let w of walls) {
        ctx.fillStyle = '#000'; ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.strokeStyle = '#D0D'; ctx.shadowColor = '#D0D'; ctx.lineWidth = 2;
        ctx.strokeRect(w.x+2, w.y+2, w.w-4, w.h-4);
    }
    ctx.shadowBlur = 0;

    pickups.forEach(p => {
        ctx.fillStyle = p.color; ctx.shadowColor = p.color; ctx.shadowBlur=10;
        ctx.fillRect(p.x-6, p.y-6, 12, 12);
    });

    if(!player.dead) player.draw();
    enemies.forEach(e => e.draw());
    bullets.forEach(b => b.draw());
    
    particles.forEach(p => {
        ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
        let s = p.size * (p.alpha ? p.life*2 : 1);
        ctx.fillRect(p.x, p.y, s, s);
    });
    ctx.globalAlpha = 1.0;

    // Floating Text
    ctx.font = "italic 900 20px sans-serif";
    ctx.textAlign = "center";
    for(let t of Style.texts) {
        ctx.fillStyle = t.color; ctx.shadowColor = t.color; ctx.shadowBlur = 5;
        let s = t.size * (t.life < 0.2 ? t.life*5 : 1);
        ctx.font = "italic 900 " + s + "px sans-serif";
        ctx.fillText(t.text, t.x, t.y);
    }

    ctx.restore();
}

function loop(timestamp) {
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    if(dt > 0.1) dt = 0.1; // Cap lag
    
    if (gameState === 'playing') update(dt);
    draw();
    requestAnimationFrame(loop);
}

function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    AudioSys.init();
    gameState = 'playing';
    level = 1;
    Style.points = 0; Style.meter = 0; Style.gradeIndex = 0;
    lastTime = performance.now();
    generateLevel();
    requestAnimationFrame(loop);
}
</script>
</body>
</html>